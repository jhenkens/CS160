%{
#include <stdio.h>
#include <stdlib.h>

#include "ast.hpp"
#include "primitive.hpp"
#include "symtab.hpp"

#define YYDEBUG 1

extern Program_ptr ast;
int yylex(void);
void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose


/* Insert your grammar into below section. Please don't just overwrite the file because of the enhanced header section. */

%token T_BOOL
%token T_ELSE
%token T_IF
%token T_INT
%token T_WHILE
%token T_VAR
%token T_FUNCTION
%token T_INTARRAY
%token T_RETURN

%token T_EQ
%token T_GT
%token T_GE
%token T_LT
%token T_LE
%token T_NE
%token T_AND
%token T_OR
%token T_NOT
%token T_PLUS
%token T_MINUS
%token T_MULT
%token T_DIVIDE

%token T_TRUE
%token T_FALSE
%token T_IDENTIFIER
%token T_INTEGER 

%token T_SEMICOLON
%token T_COMMA
%token T_BAR
%token T_LBRACE
%token T_RBRACE
%token T_RPAREN
%token T_LPAREN
%token T_LBRACKET
%token T_RBRACKET
%token T_ASSIGN

%left T_OR
%left T_AND
%left T_EQ T_NE
%left T_LT T_LE T_GT T_GE
%left T_MINUS T_PLUS
%left T_DIVIDE T_MULT
%right T_NOT UMINUS

%%

Program         : Function Program {
                    $$.u_func_list = $2.u_func_list;
                    $$.u_func_list->push_front($1.u_func);
                    ast = new Program($$.u_func_list);}
                | { $$.u_func_list = new list<Func_ptr>();
                    ast = new Program($$.u_func_list);}
                ;

ReturnType      : T_BOOL {$$.u_type = new TBool();}
                | T_INT {$$.u_type = new TInt();}
                ;

ParameterList   : T_LPAREN T_RPAREN {$$.u_param_list = new list<Param_ptr>();}
                | T_LPAREN Parameter AdditionalParam T_RPAREN {$$.u_param_list = $3.u_param_list; $$.u_param_list->push_front($2.u_param);};
                ;

AdditionalParam : T_COMMA Parameter AdditionalParam {$$.u_param_list = $3.u_param_list; $$.u_param_list->push_front($2.u_param);}
                | {$$.u_param_list = new list<Param_ptr>();}
                ;

Parameter       : ReturnType T_IDENTIFIER {$$.u_param = new Param( $1.u_type, new SymName($2.u_base_charptr));}
                ;

Function        : T_FUNCTION ReturnType T_IDENTIFIER ParameterList FunctionBody { $$.u_func = new Func($2.u_type, new SymName($3.u_base_charptr), $4.u_param_list, $5.u_function_block);}
                ;

FunctionBody    : T_LBRACE Declarations NestedFunctions Statements ReturnStatement T_RBRACE { $$.u_function_block = new Function_block(
                                            $2.u_decl_list,$3.u_func_list,$4.u_stat_list, $5.u_return);}
                ;

DeclTypes       : ReturnType
                | T_INTARRAY T_LBRACKET T_INTEGER T_RBRACKET {$$.u_type = new TIntArray(new Primitive($3.u_base_int));}
                ;

Declarations    : Declaration Declarations { $$.u_decl_list = $2.u_decl_list; $$.u_decl_list->push_front($1.u_decl);}
                | {$$.u_decl_list = new list<Decl_ptr>();}
                ;

Declaration     : T_VAR DeclTypes T_IDENTIFIER AddtlIdens T_SEMICOLON { $4.u_symname_list->push_front(new SymName($3.u_base_charptr)); $$.u_decl = new Decl($2.u_type, $4.u_symname_list);}
                ;

AddtlIdens      : T_COMMA T_IDENTIFIER AddtlIdens {$$.u_symname_list = $3.u_symname_list; $$.u_symname_list->push_front(new SymName($2.u_base_charptr));}
                | {$$.u_symname_list = new list<SymName_ptr>();}
                ;

NestedFunctions : Function NestedFunctions { $$.u_func_list = $2.u_func_list; $$.u_func_list->push_front($1.u_func);}
                | {$$.u_func_list = new list<Func_ptr>();}
                ;

Statements      : Statement Statements {$$.u_stat_list = $2.u_stat_list; $$.u_stat_list->push_front($1.u_stat);}
                | {$$.u_stat_list = new list<Stat_ptr>();}
                ;

Statement       : Assignment
                | FunctionCall
                | IfStatement
                | WhileStatement
                ;

Assignment      : T_IDENTIFIER T_ASSIGN Expr T_SEMICOLON {$$.u_stat = new Assignment(new SymName($1.u_base_charptr),$3.u_expr);}
                | T_IDENTIFIER T_LBRACKET Expr T_RBRACKET T_ASSIGN Expr T_SEMICOLON {$$.u_stat = new ArrayAssignment(new SymName($1.u_base_charptr), $3.u_expr, $6.u_expr);}
                ;

FunctionCall    : T_IDENTIFIER T_ASSIGN T_IDENTIFIER ParameterValues T_SEMICOLON { $$.u_stat = new Call(new SymName($1.u_base_charptr),new SymName($3.u_base_charptr),$4.u_expr_list);}
                | T_IDENTIFIER T_LBRACKET Expr T_RBRACKET T_ASSIGN T_IDENTIFIER ParameterValues T_SEMICOLON { $$.u_stat = new ArrayCall(new SymName($1.u_base_charptr),$3.u_expr,new SymName($6.u_base_charptr),$7.u_expr_list);}
                ;

ParameterValues : T_LPAREN T_RPAREN {$$.u_expr_list = new list<Expr_ptr>();}
                | T_LPAREN Expr AdditionalVals T_RPAREN {$$.u_expr_list = $3.u_expr_list; $$.u_expr_list->push_front($2.u_expr);}
                ;

AdditionalVals  : T_COMMA Expr AdditionalVals {$$.u_expr_list = $3.u_expr_list; $$.u_expr_list->push_front($2.u_expr);}
                | {$$.u_expr_list = new list<Expr_ptr>();}
                ;

IfStatement     : T_IF T_LPAREN Expr T_RPAREN CodeBlock ElseStatement {
                                if($6.u_nested_block==NULL){
                                    $$.u_stat = new IfNoElse($3.u_expr, $5.u_nested_block);
                                } else{
                                    $$.u_stat = new IfWithElse($3.u_expr, $5.u_nested_block, $6.u_nested_block);
                                }}
                ;

ElseStatement   : T_ELSE CodeBlock {$$.u_nested_block = $2.u_nested_block;}
                | {$$.u_nested_block = NULL;}
                ;

WhileStatement  : T_WHILE T_LPAREN Expr T_RPAREN CodeBlock {$$.u_stat = new WhileLoop($3.u_expr,$5.u_nested_block);}
                ;

ReturnStatement : T_RETURN Expr T_SEMICOLON { $$.u_return = new Return($2.u_expr);}
                ;

CodeBlock       : T_LBRACE Statements T_RBRACE {$$.u_nested_block = new Nested_block($2.u_stat_list);}
                ;


/* Starting Expression Section */
Expr            : T_LPAREN Expr T_RPAREN {$$.u_expr = $2.u_expr;}
                | T_BAR Expr T_BAR {$$.u_expr = new Magnitude($2.u_expr);}
                | Expr T_AND Expr {$$.u_expr = new And($1.u_expr,$3.u_expr);}
                | Expr T_OR Expr {$$.u_expr = new Or($1.u_expr,$3.u_expr);}
                | Expr T_LT Expr {$$.u_expr = new Lt($1.u_expr,$3.u_expr);}
                | Expr T_GT Expr {$$.u_expr = new Gt($1.u_expr,$3.u_expr);}
                | Expr T_LE Expr {$$.u_expr = new Lteq($1.u_expr,$3.u_expr);}
                | Expr T_GE Expr {$$.u_expr = new Gteq($1.u_expr,$3.u_expr);}
                | Expr T_EQ Expr {$$.u_expr = new Compare($1.u_expr,$3.u_expr);}
                | Expr T_NE Expr {$$.u_expr = new Noteq($1.u_expr,$3.u_expr);}
                | T_TRUE {$$.u_expr = new BoolLit(new Primitive($1.u_base_int));}
                | T_FALSE {$$.u_expr = new BoolLit(new Primitive($1.u_base_int));}
                | T_NOT Expr {$$.u_expr = new Not($2.u_expr);}
                | Expr T_PLUS Expr  {$$.u_expr = new Plus($1.u_expr,$3.u_expr);}
                | Expr T_MINUS Expr  {$$.u_expr = new Minus($1.u_expr,$3.u_expr);}
                | Expr T_MULT Expr  {$$.u_expr = new Times($1.u_expr,$3.u_expr);}
                | Expr T_DIVIDE Expr  {$$.u_expr = new Div($1.u_expr,$3.u_expr);}
                | T_MINUS Expr %prec UMINUS  {$$.u_expr = new Uminus($2.u_expr);}
                | T_INTEGER {$$.u_expr = new IntLit ( new Primitive ( $1.u_base_int));}
                | T_IDENTIFIER T_LBRACKET Expr T_RBRACKET {$$.u_expr = new ArrayAccess(new SymName($1.u_base_charptr),$3.u_expr);}
                | T_IDENTIFIER {$$.u_expr = new Ident ( new SymName($1.u_base_charptr));}
                ;


%%

extern int yylineno;

void yyerror(const char *s) {
	fprintf(stderr, "%s at line %d\n", s, yylineno);
	exit(1);
	return;
}
